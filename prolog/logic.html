<!DOCTYPE html>
<html>
  <head>
    <title>Logical Foundations of Prolog</title>
    <meta name=viewport content="width=device-width, initial-scale=1">
    <meta name="description" content="Logical Foundations of Prolog">
    <meta name="keywords" content="Prolog,Logic,Predicate Logic">
    <meta name="author" content="Markus Triska">
    <meta charset="utf-8" />
    <link rel="stylesheet" type="text/css" href="prolog.css">
    <link rel="stylesheet" type="text/css" href="toc.css">
  </head>
  <body style="padding-left: 5%; padding-right: 5%; padding-bottom: 3cm">

    <br><br>
    <br><br>
    <center><h1>Logical Foundations of Prolog</h1></center>
    <br><br>


    <b>Logic</b> is a very broad, interesting and also beautiful
    topic.

    <br><br>

    <table>
      <tr>
        <td><i>Video</i>:</td>
        <td><a href="videos/logic"><img src="videos/t_logic.png" alt="Logic"></a>
        </td>
      </tr>
    </table>

    <br><br>

    There is no universally accepted definition for what logic
    actually is. However, what we can say is that logic is
    concerned&mdash;at least among other things&mdash;with the
    properties of, and the relations between:

    <ul>

      <li><b>syntax</b><br>

        This is the formalization of languages according to rules.  It
      includes for example defining what a formula or a sentence looks
      like.
      </li>

      <li><b>semantics</b><br>

        This is assigning <i>meaning</i> to the
      syntactic constructs of languages. This includes
      defining how sentences are interpreted, and stating under what
        conditions they are true.
      </li>

      <li><b>inferences</b><br> This stems from the Latin
      verb <i>inferre</i>, which means "to carry forward". An
      inference <i>rule</i> allows us to derive logical consequences
      from premises, i.e., to bring premises to conclusions.
      </li>
    </ul>

    There are different <i>logics</i>, because changing these
    components yields different frameworks.

    <br><br>

    Logic and computation are closely related. For example, we can
    formulate logical statements about computations, and derive
    logical consequences from them that correspond to <i>results</i>
    of the computations.

    <br><br>

    It can be argued that programming is a form
    of <i>theory&nbsp;building</i>. See
    for example <a href="http://pages.cs.wisc.edu/~remzi/Naur.pdf"><i>Programming
    as Theory Building</i></a> by Peter Naur.

    <br><br>

    Prolog is based on classical <b>first-order predicate logic</b>.

    <br><br>

    <table>
      <tr>
        <td><i>Video</i>:</td>
        <td><a href="videos/predicate_logic"><img src="videos/t_predicate_logic.png" alt="Predicate Logic"></a>
        </td>
      </tr>
    </table>

    <br><br>

    In fact, the core of Prolog is restricted to a
    Turing&nbsp;complete <i>subset</i> of first-order predicate logic
    called <a href="https://en.wikipedia.org/wiki/Horn_clause"><b>Horn&nbsp;clauses</b></a>.


    <table>
      <tr>
        <td><i>Video</i>:</td>
        <td><a href="videos/horn_clauses"><img src="videos/t_horn_clauses.png" alt="Horn Clauses"></a>
        </td>
      </tr>
    </table>

    <br><br>

    A Prolog program is a sequence of Horn clauses that define what is
    true, and what follows from what.

    <br><br>

    Internally, Prolog uses a proof method
    called <a href="https://en.wikipedia.org/wiki/Resolution_(logic)"><b>resolution</b></a>. Resolution
    is based on the idea of proof by contradiction: To prove a logical
    consequence of a set of axioms, we assume the opposite of what we
    want to prove, and show that this contradicts the axioms which we
    take for granted.

    <br><br>

    Logically, when Prolog answers a query, it tries to find
    a <i>resolution&nbsp;refutation</i> of the negated query and the
    set of clauses that constitute a program. When a refutation is
    found, it means that the query, with the appropriate bindings, is
    a logical <i>consequence</i> of the program.

    <br><br>

    For Horn clauses, resolution can be implemented very efficiently.

    <br><br>

    Resolution leaves a lot of freedom in <i>how</i> the search for
    contradictions is to be performed. Accordingly, Prolog programs
    can be interpreted with different evaluation strategies. The
    default execution strategy is called SLDNF&nbsp;resolution:
    SLD&nbsp;resolution with <i>negation as finite failure</i>.
    Another popular execution strategy of Prolog programs is called
    SLG&nbsp;resolution, also known
    as&nbsp;<a href="memoization#tabling"><i>tabling</i></a>. Other
    variants include iterative deepening and various heuristics.

    <br><br>

    Regarded as a theorem prover, Prolog with its default execution
    strategy is <i>incomplete</i> in the sense that, in&nbsp;general,
    not <i>all</i> logical consequences of a theory are found.

    <br><br>

    Even though Prolog itself is incomplete in general, we can use it
    to implement <i>complete</i> <a href="theoremproving">theorem
    provers</a>. This is because Prolog is a <i>programming
    language</i> and can be used to express all known computations. In
    addition, we can interpret Prolog programs with variants of
    resolution that are themselves complete.

    <br><br>

    Since Prolog allows us to decouple the <i>logical description</i>
    of what holds (i.e., the Horn&nbsp;clauses) from <i>how</i> the
    search for logical consequences is performed, we can
    write
    <a href="https://www.doc.ic.ac.uk/~rak/papers/algorithm%20=%20logic%20+%20control.pdf"><i>Algorithm&nbsp;=&nbsp;Logic&nbsp;+&nbsp;Control</i></a>.


    <br><br><br>
    <b><a href="/prolog">More about Prolog</a></b>

    <br><br><br>

    <b><a href="/">Main page</a></b>
    <script src="jquery.js"></script>
    <script src="toc.js"></script>
  </body>
</html>
